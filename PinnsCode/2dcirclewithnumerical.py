# -*- coding: utf-8 -*-
"""SW2Dcicular.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aVFQVniAEudjUVqT38988E7QsqWL9KKW
"""

!pip install deepxde
import matplotlib.pyplot as plt
import numpy as np
import deepxde as dde
from deepxde.backend import tf
dde.config.set_random_seed(42)
dde.config.real.set_float32()

dim_input = 3
dim_output = 3

scale_h = 1000.0

Time = 2.0

X_min = 0.0
X_max = 100.0
Y_min = 0.0
Y_max = 100.0
X_0 = 50.0
g = 9.81

def on_initial(_, on_initial):
    return on_initial

def boundary_x1(x, on_boundary):
    return on_boundary and np.isclose(x[0], X_min)

def boundary_x2(x, on_boundary):
    return on_boundary and np.isclose(x[0], X_max)
def boundary_y1(x, on_boundary):
    return on_boundary and np.isclose(x[1], Y_min)

def boundary_y2(x, on_boundary):
    return on_boundary and np.isclose(x[1], Y_max)
# def func_IC_h(x):
#     h_r = 1.0  # Height on the right side
#     h_l = 0.02  # Height on the left side
#     return np.where(x[:, 0:1] <= X_0, h_r, h_l)
from scipy.interpolate import RegularGridInterpolator

dde.config.set_random_seed(42)
dde.config.real.set_float32()
uploaded = files.upload()
# Load the numerical data
h_numerical = np.load("h_numerical.npy")  # Shape (4, 401, 401)
time_numerical = np.linspace(0.0, 0.6, 4)  # Available time steps: [0, 0.1, 0.2, 0.3]
x_numerical = np.linspace(0.0, 100.0, 401)
y_numerical = np.linspace(0.0, 100.0, 401)

# Create an interpolator for the initial condition
interpolator = RegularGridInterpolator(
    (time_numerical, x_numerical, y_numerical), h_numerical, bounds_error=False, fill_value=None
)

dim_input = 3
dim_output = 3

# Domain and parameters
Time = 3.0  # Train for times up to 2 seconds
X_min, X_max = 0.0, 100.0
Y_min, Y_max = 0.0, 100.0
g = 5.81

# Define the initial condition for h, u, and v using t=0 from `h_numerical`
def func_IC_h(x):
    t = x[:, 2]  # Extract time
    points = np.column_stack((np.full_like(t, 0.6), x[:, 0], x[:, 1]))  # t=0 for IC
    h_interp = interpolator(points)
    return np.expand_dims(h_interp, axis=1)

def func_IC_u(x):
    return np.zeros([len(x), 1])

def func_IC_v(x):
    return np.zeros([len(x), 1])

def func_BC_all(x):
    return np.zeros([len(x), 1])

# Define the shallow water PDE
def pde(x, y):
    h, u, v = y[:, 0:1], y[:, 1:2], y[:, 2:3]

    U1, U2, U3 = h, h * u, h * v
    E1, E2, E3 = h * u, h * u**2 + 0.5 * g * h**2, h * u * v
    G1, G2, G3 = h * v, h * u * v, h * v**2 + 0.5 * g * h**2

    U1_t = tf.gradients(U1, x)[0][:, 2:3]
    U2_t = tf.gradients(U2, x)[0][:, 2:3]
    U3_t = tf.gradients(U3, x)[0][:, 2:3]

    E1_x = tf.gradients(E1, x)[0][:, 0:1]
    E2_x = tf.gradients(E2, x)[0][:, 0:1]
    E3_x = tf.gradients(E3, x)[0][:, 0:1]

    G1_y = tf.gradients(G1, x)[0][:, 1:2]
    G2_y = tf.gradients(G2, x)[0][:, 1:2]
    G3_y = tf.gradients(G3, x)[0][:, 1:2]

    equaz_1 = U1_t + E1_x + G1_y
    equaz_2 = U2_t + E2_x + G2_y
    equaz_3 = U3_t + E3_x + G3_y

    return [equaz_1, equaz_2, equaz_3]
N = 401  # Change N to match the dimensions of t0_data
X_plot, Y_plot = np.meshgrid(np.linspace(0, 100, N), np.linspace(0, 100, N))
X_flat = X_plot.flatten()
Y_flat = Y_plot.flatten()
T_flat = np.zeros_like(X_flat)  # Assuming t=0 for the initial condition
Q_plot = np.column_stack((X_flat, Y_flat, T_flat))

# Use the original shape of t0_data when reshaping:
h_plot = func_IC_h(Q_plot) # Reshape to t0_data's shape (401, 401)
h_plot = h_plot.reshape(X_plot.shape)
# Plot the initial condition with a surface plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X_plot, Y_plot, h_plot, cmap='viridis') # Use X_plot,Y_plot with dimensions (401,401)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Water Surface Height')
ax.set_title('Dam Break Initial Condition at t = 0')
plt.show()
# Modify boundary conditions accordingly
geom = dde.geometry.Rectangle([X_min, Y_min],[X_max, Y_max])
timedomain = dde.geometry.TimeDomain(0.0, Time)
geomtime = dde.geometry.GeometryXTime(geom, timedomain)

IC_h = dde.IC(geomtime, func_IC_h, lambda x, _: x[2] <= 0.4, component=0)

IC_u = dde.IC(geomtime, func_IC_u, on_initial, component = 1)
IC_v = dde.IC(geomtime, func_IC_v, on_initial, component = 2)

BC_u1 = dde.DirichletBC(geomtime, func_BC_all, boundary_x1, component = 1)
BC_u2 = dde.DirichletBC(geomtime, func_BC_all, boundary_x2, component = 1)
BC_v1 = dde.DirichletBC(geomtime, func_BC_all, boundary_y1, component = 2)
BC_v2 = dde.DirichletBC(geomtime, func_BC_all, boundary_y2, component = 2)

IC_BC = [IC_h, IC_u, IC_v, BC_u1, BC_u2, BC_v1, BC_v2]

# Create the TimePDE data object
data = dde.data.TimePDE(
    geomtime, pde, IC_BC,
    num_domain=20000,
    num_boundary=1000,
    num_initial=20000)

# Define the neural network model
net = dde.maps.FNN(
    layer_sizes=[dim_input] + [100] * 5 + [dim_output],
    activation="tanh",
    kernel_initializer="Glorot uniform")

os.makedirs("solution_outputs_circularNum", exist_ok=True)
model = dde.Model(data, net)

model.compile('adam', lr=0.0001)
# Train the model and capture the training history
losshistory, train_state = model.train(iterations=20000)
loss_train = losshistory.loss_train

# Compute total loss by summing all components at each epoch
total_loss = [sum(l) for l in loss_train]
df = pd.DataFrame({"Step": range(1, len(total_loss)+1), "Loss": total_loss})
df.to_csv("solution_outputs_circularNum/training_loss_circularNum.csv", index=False)

plt.figure()
plt.semilogy(total_loss, color='red', label="Training Loss (Tanh Activation)")
plt.xlabel("# Steps")
plt.ylabel("Loss")
plt.title("Loss History")
plt.legend()
plt.tight_layout()
plt.savefig("solution_outputs_circularNum/training_loss_circularNum.png", dpi=300)
plt.close()

plot_Time = [0.0, 0.5, 0.8, 1.0, 1.5, 2.0]


N_x = 500
N_y =500

X_plot, Y_plot = np.meshgrid(np.linspace(X_min, X_max, N_x), np.linspace(Y_min, Y_max, N_y))
X_plot = X_plot.flatten()
Y_plot = Y_plot.flatten()


for t in plot_Time:  # Loop over the time steps
    T_plot = np.ones_like(X_plot) * t
    Q_plot = np.column_stack((X_plot, Y_plot, T_plot))
    W_plot = model.predict(Q_plot)
    Z_plot = W_plot[:, 0]  # Water surface height (h)
    Z_plot = np.reshape(Z_plot, (N_y, N_x))  # Reshape to 2D grid for plotting
    pd.DataFrame(Z_plot).to_csv(f"solution_outputs_circularNum/height_circularNum_t{t:.2f}.csv", index=False)

    # Create a figure with two subplots
    fig = plt.figure(figsize=(14, 6))

    # 3D Surface plot on the left
    ax_surface = fig.add_subplot(121, projection='3d')
    ax_surface.plot_surface(X_plot.reshape(N_y, N_x), Y_plot.reshape(N_y, N_x), Z_plot, cmap='viridis')
    ax_surface.set_xlabel('X')
    ax_surface.set_ylabel('Y')
    ax_surface.set_zlabel('Water Height')
    ax_surface.set_title(f'3D Surface at T = {t:.2f} s')

    # Contour (Heat map) plot on the right
    ax_contour = fig.add_subplot(122)
    heatmap = ax_contour.imshow(Z_plot, origin='lower', cmap='viridis', aspect='auto', extent=[X_min, X_max, Y_min, Y_max]) # Added extent
    ax_contour.set_xlabel('X')
    ax_contour.set_ylabel('Y')
    ax_contour.set_title(f'Contour Plot at T = {t:.2f} s')
    plt.colorbar(heatmap, ax=ax_contour, label='Water Height')

    plt.tight_layout()
    plt.show()
